<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BBOUZOK</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Malgun Gothic", sans-serif;
        background: #2a2a2a;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
      }
      #container {
        background: #1a1a1a;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }
      canvas {
        display: block;
        background: #dcdcdc;
        border-radius: 5px;
        cursor: crosshair;
      }
      #info {
        color: #fff;
        margin-top: 15px;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        font-size: 14px;
      }
      .info-item {
        background: #333;
        padding: 8px 12px;
        border-radius: 5px;
      }
      .controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      button {
        padding: 8px 16px;
        background: #4a90e2;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }
      button:hover {
        background: #357abd;
      }
      button:active {
        transform: scale(0.95);
      }
      .legend {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        font-size: 13px;
        color: #ccc;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="canvas" width="1200" height="800"></canvas>
      <div id="info">
        <div class="info-item">경과 시간: <span id="time">00:00</span></div>
        <div class="info-item">
          배속: <span id="speed">5.00</span>x <span id="paused"></span>
        </div>
        <div class="info-item">
          O: <span id="countO">0</span> | A: <span id="countA">0</span> | B:
          <span id="countB">0</span>
        </div>
        <div class="info-item">
          평균속도 A: <span id="avgSpeedA">0</span> | B:
          <span id="avgSpeedB">0</span>
        </div>
        <div class="info-item">
          평균크기 A: <span id="avgSizeA">0</span> | B:
          <span id="avgSizeB">0</span>
        </div>
        <div class="info-item">FPS: <span id="fps">0</span></div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(0, 180, 0)"></div>
          <span>O (먹이)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(0, 0, 255)"></div>
          <span>A (초식)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgb(255, 0, 0)"></div>
          <span>B (육식)</span>
        </div>
      </div>
      <div class="controls">
        <button onclick="togglePause()">일시정지 (Space)</button>
        <button onclick="speedUp()">속도 증가 (+)</button>
        <button onclick="speedDown()">속도 감소 (-)</button>
        <button onclick="reset()">리셋 (R)</button>
      </div>
    </div>

    <script>
      const config = {
        World_W: 1200,
        World_H: 800,
        FPS: 60,

        Init_O_Count: 50,
        Init_A_Count: 10,
        Init_B_Count: 5,

        O_Spawn_Interval_Seconds: 10.0,
        O_Spawn_Count_Per_Interval: 20,
        O_Radius: 3,
        Color_O: [0, 180, 0],

        A_Detect_O_Radius: 150,
        A_Detect_B_Radius: 200,
        A_Eat_To_Reproduce_Count: 3,
        A_Reproduce_Offspring_Count: 3,
        A_Initial_Speed: 60,
        A_Initial_Shape_Length: 5,
        Color_A: [0, 0, 255],

        B_Detect_A_Radius: 180,
        B_Eat_To_Reproduce_Count: 6,
        B_Reproduce_Offspring_Count: 1,
        B_Initial_Speed: 70,
        B_Initial_Shape_Length: 5,
        Color_B: [255, 0, 0],

        Mutation_Chance_Per_Gene: 0.9,
        Mutation_Max_Ratio: 0.9,

        A_Speed_Min_Max: [1, 50],
        A_Shape_Length_Min_Max: [0.1, 2000],

        B_Speed_Min_Max: [1, 50.3],
        B_Shape_Length_Min_Max: [0.1, 1.236],

        Default_Simulation_Speed_Multiplier: 5.0,
        Background_Color: [220, 220, 220],
        Reproduction_Offset_Radius: 20,

        A_Max_Hunger: 150.0,
        A_Hunger_Increase_Per_Second: 1.5,
        A_Eat_Reduces_Hunger: 50.0,

        B_Max_Hunger: 80.0,
        B_Hunger_Increase_Per_Second: 2.0,
        B_Eat_Reduces_Hunger: 40.0,
      };

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let allCreatures = [];
      let oSpawnTimer = 0;
      let simulationTime = 0;
      let paused = false;
      let speedMultiplier = config.Default_Simulation_Speed_Multiplier;
      let lastTime = performance.now();
      let fpsCounter = 0;
      let fpsTime = 0;

      class Vector2 {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        add(v) {
          return new Vector2(this.x + v.x, this.y + v.y);
        }
        subtract(v) {
          return new Vector2(this.x - v.x, this.y - v.y);
        }
        multiply(scalar) {
          return new Vector2(this.x * scalar, this.y * scalar);
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        normalize() {
          const len = this.length();
          return len > 0
            ? new Vector2(this.x / len, this.y / len)
            : new Vector2(0, 0);
        }
        distance(v) {
          return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2);
        }
      }

      function randomPosition() {
        return new Vector2(
          Math.random() * config.World_W,
          Math.random() * config.World_H
        );
      }

      function randomDirection() {
        const angle = Math.random() * Math.PI * 2;
        return new Vector2(Math.cos(angle), Math.sin(angle));
      }

      function calculatePolygonPoints(center, shapeLengths) {
        const points = [];
        for (let i = 0; i < shapeLengths.length; i++) {
          const angle = (i * 45 * Math.PI) / 180;
          const x = center.x + shapeLengths[i] * Math.cos(angle);
          const y = center.y + shapeLengths[i] * Math.sin(angle);
          points.push({ x, y });
        }
        return points;
      }

      function getAvgShapeLength(shapeLengths) {
        if (!shapeLengths.length) return 0;
        return shapeLengths.reduce((a, b) => a + b, 0) / shapeLengths.length;
      }

      // 점과 다각형 충돌 검사 (Ray Casting Algorithm)
      function pointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x,
            yi = polygon[i].y;
          const xj = polygon[j].x,
            yj = polygon[j].y;
          const intersect =
            yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // 다각형과 다각형 충돌 검사 (SAT - Separating Axis Theorem)
      function polygonsCollide(poly1, poly2) {
        // 먼저 빠른 거리 체크
        const axes = [];

        // 각 다각형의 edge에서 법선 벡터 추출
        function getAxes(poly) {
          const result = [];
          for (let i = 0; i < poly.length; i++) {
            const p1 = poly[i];
            const p2 = poly[(i + 1) % poly.length];
            const edge = new Vector2(p2.x - p1.x, p2.y - p1.y);
            result.push(new Vector2(-edge.y, edge.x).normalize());
          }
          return result;
        }

        axes.push(...getAxes(poly1), ...getAxes(poly2));

        for (const axis of axes) {
          const proj1 = projectPolygon(poly1, axis);
          const proj2 = projectPolygon(poly2, axis);

          if (proj1.max < proj2.min || proj2.max < proj1.min) {
            return false; // 분리축 발견
          }
        }
        return true; // 모든 축에서 겹침
      }

      function projectPolygon(poly, axis) {
        let min = axis.x * poly[0].x + axis.y * poly[0].y;
        let max = min;

        for (let i = 1; i < poly.length; i++) {
          const proj = axis.x * poly[i].x + axis.y * poly[i].y;
          if (proj < min) min = proj;
          if (proj > max) max = proj;
        }
        return { min, max };
      }

      // 원과 다각형 충돌 검사
      function circlePolygonCollide(center, radius, polygon) {
        // 1. 원의 중심이 다각형 내부에 있는지 확인
        if (pointInPolygon(center, polygon)) return true;

        // 2. 원과 다각형 각 edge의 최단 거리 확인
        for (let i = 0; i < polygon.length; i++) {
          const p1 = polygon[i];
          const p2 = polygon[(i + 1) % polygon.length];

          if (distanceToSegment(center, p1, p2) <= radius) {
            return true;
          }
        }

        return false;
      }

      function distanceToSegment(point, p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared === 0) {
          return Math.sqrt((point.x - p1.x) ** 2 + (point.y - p1.y) ** 2);
        }

        let t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const closestX = p1.x + t * dx;
        const closestY = p1.y + t * dy;

        return Math.sqrt((point.x - closestX) ** 2 + (point.y - closestY) ** 2);
      }

      class Origin {
        constructor(position) {
          this.id = Math.random();
          this.position = position;
          this.color = config.Color_O;
          this.radius = config.O_Radius;
          this.isAlive = true;
          this.type = "Origin";
        }

        draw() {
          ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
          ctx.beginPath();
          ctx.arc(
            this.position.x,
            this.position.y,
            this.radius,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        update(dt, creatures) {}
      }

      class PolygonCreature {
        constructor(position, color, speed, shapeLength) {
          this.id = Math.random();
          this.position = position;
          this.color = color;
          this.speed = speed;
          this.shapeLengths = Array(8).fill(shapeLength);
          this.eatCounter = 0;
          this.currentDirection = randomDirection();
          this.isAlive = true;
          this.hunger = 0;
          this.maxHunger = 100;
          this.hungerIncreaseRate = 1.0;
          this.eatReducesHunger = 0;
          this.speedMinMax = [1, 100];
          this.shapeLengthMinMax = [1, 50];
        }

        getPolygonPoints() {
          return calculatePolygonPoints(this.position, this.shapeLengths);
        }

        draw() {
          const points = this.getPolygonPoints();
          if (points.length < 3) return;

          ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.closePath();
          ctx.fill();
        }

        updateHunger(dt) {
          if (!this.isAlive) return;
          this.hunger += this.hungerIncreaseRate * dt;
          if (this.hunger >= this.maxHunger) {
            this.isAlive = false;
          }
        }

        eatAction() {
          this.hunger = Math.max(0, this.hunger - this.eatReducesHunger);
        }

        handleBoundary() {
          const avgRadius = getAvgShapeLength(this.shapeLengths);
          let bounced = false;

          if (this.position.x - avgRadius < 0) {
            this.position.x = avgRadius;
            this.currentDirection.x *= -1;
            bounced = true;
          } else if (this.position.x + avgRadius > config.World_W) {
            this.position.x = config.World_W - avgRadius;
            this.currentDirection.x *= -1;
            bounced = true;
          }

          if (this.position.y - avgRadius < 0) {
            this.position.y = avgRadius;
            this.currentDirection.y *= -1;
            bounced = true;
          } else if (this.position.y + avgRadius > config.World_H) {
            this.position.y = config.World_H - avgRadius;
            this.currentDirection.y *= -1;
            bounced = true;
          }

          if (bounced) {
            this.currentDirection = this.currentDirection.normalize();
          }
        }

        applyMutation() {
          let mutatedSpeed = this.speed;
          const mutatedShapeLengths = [...this.shapeLengths];

          if (Math.random() < config.Mutation_Chance_Per_Gene) {
            const strength =
              (Math.random() * 2 - 1) * config.Mutation_Max_Ratio;
            mutatedSpeed *= 1 + strength;
            mutatedSpeed = Math.max(
              this.speedMinMax[0],
              Math.min(this.speedMinMax[1], mutatedSpeed)
            );
          }

          for (let i = 0; i < mutatedShapeLengths.length; i++) {
            if (Math.random() < config.Mutation_Chance_Per_Gene) {
              const strength =
                (Math.random() * 2 - 1) * config.Mutation_Max_Ratio;
              mutatedShapeLengths[i] *= 1 + strength;
              mutatedShapeLengths[i] = Math.max(
                this.shapeLengthMinMax[0],
                Math.min(this.shapeLengthMinMax[1], mutatedShapeLengths[i])
              );
            }
          }

          return { speed: mutatedSpeed, shapeLengths: mutatedShapeLengths };
        }
      }

      class Alpha extends PolygonCreature {
        constructor(position, speed = null, shapeLengths = null) {
          super(
            position,
            config.Color_A,
            speed ?? config.A_Initial_Speed,
            config.A_Initial_Shape_Length
          );
          if (shapeLengths) {
            this.shapeLengths = shapeLengths.map((sl) =>
              Math.max(config.A_Shape_Length_Min_Max[0], sl)
            );
          }
          this.type = "Alpha";
          this.detectionRadiusO = config.A_Detect_O_Radius;
          this.detectionRadiusB = config.A_Detect_B_Radius;
          this.maxHunger = config.A_Max_Hunger;
          this.hungerIncreaseRate = config.A_Hunger_Increase_Per_Second;
          this.eatReducesHunger = config.A_Eat_Reduces_Hunger;
          this.speedMinMax = config.A_Speed_Min_Max;
          this.shapeLengthMinMax = config.A_Shape_Length_Min_Max;
          this.speed = Math.max(
            this.speedMinMax[0],
            Math.min(this.speedMinMax[1], this.speed)
          );
        }

        update(dt, creatures) {
          if (!this.isAlive) return;
          this.updateHunger(dt);
          if (!this.isAlive) return;

          let closestPredator = null;
          let minDistB = Infinity;

          for (const c of creatures) {
            if (c.type === "Beta" && c.isAlive) {
              const dist = this.position.distance(c.position);
              if (dist < this.detectionRadiusB && dist < minDistB) {
                minDistB = dist;
                closestPredator = c;
              }
            }
          }

          let targetDir = null;
          if (closestPredator) {
            const escape = this.position.subtract(closestPredator.position);
            if (escape.length() > 0) targetDir = escape.normalize();
          } else {
            let closestPrey = null;
            let minDistO = Infinity;

            for (const c of creatures) {
              if (c.type === "Origin" && c.isAlive) {
                const dist = this.position.distance(c.position);
                if (dist < this.detectionRadiusO && dist < minDistO) {
                  minDistO = dist;
                  closestPrey = c;
                }
              }
            }

            if (closestPrey) {
              const chase = closestPrey.position.subtract(this.position);
              if (chase.length() > 0) targetDir = chase.normalize();
            } else {
              if (Math.random() < 0.1) {
                this.currentDirection = randomDirection();
              }
              targetDir = this.currentDirection.normalize();
            }
          }

          if (targetDir && targetDir.length() > 0) {
            this.currentDirection = targetDir;
          }

          const move = this.currentDirection.multiply(this.speed * dt);
          this.position = this.position.add(move);
          this.handleBoundary();

          // 충돌 검사 - 다각형과 원 충돌
          const myPolygon = this.getPolygonPoints();
          for (const c of creatures) {
            if (c.type === "Origin" && c.isAlive) {
              if (circlePolygonCollide(c.position, c.radius, myPolygon)) {
                c.isAlive = false;
                this.eatCounter++;
                this.eatAction();
                break;
              }
            }
          }

          if (this.eatCounter >= config.A_Eat_To_Reproduce_Count) {
            this.reproduce(creatures);
          }
        }

        reproduce(creatures) {
          this.eatCounter = 0;
          for (let i = 0; i < config.A_Reproduce_Offspring_Count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * config.Reproduction_Offset_Radius;
            const offset = new Vector2(
              Math.cos(angle),
              Math.sin(angle)
            ).multiply(radius);
            let pos = this.position.add(offset);
            pos.x = Math.max(0, Math.min(config.World_W, pos.x));
            pos.y = Math.max(0, Math.min(config.World_H, pos.y));

            const mutated = this.applyMutation();
            creatures.push(new Alpha(pos, mutated.speed, mutated.shapeLengths));
          }
        }
      }

      class Beta extends PolygonCreature {
        constructor(position, speed = null, shapeLengths = null) {
          super(
            position,
            config.Color_B,
            speed ?? config.B_Initial_Speed,
            config.B_Initial_Shape_Length
          );
          if (shapeLengths) {
            this.shapeLengths = shapeLengths.map((sl) =>
              Math.max(config.B_Shape_Length_Min_Max[0], sl)
            );
          }
          this.type = "Beta";
          this.detectionRadiusA = config.B_Detect_A_Radius;
          this.maxHunger = config.B_Max_Hunger;
          this.hungerIncreaseRate = config.B_Hunger_Increase_Per_Second;
          this.eatReducesHunger = config.B_Eat_Reduces_Hunger;
          this.speedMinMax = config.B_Speed_Min_Max;
          this.shapeLengthMinMax = config.B_Shape_Length_Min_Max;
          this.speed = Math.max(
            this.speedMinMax[0],
            Math.min(this.speedMinMax[1], this.speed)
          );
        }

        update(dt, creatures) {
          if (!this.isAlive) return;
          this.updateHunger(dt);
          if (!this.isAlive) return;

          let closestPrey = null;
          let minDistA = Infinity;

          for (const c of creatures) {
            if (c.type === "Alpha" && c.isAlive) {
              const dist = this.position.distance(c.position);
              if (dist < this.detectionRadiusA && dist < minDistA) {
                minDistA = dist;
                closestPrey = c;
              }
            }
          }

          let targetDir = null;
          if (closestPrey) {
            const chase = closestPrey.position.subtract(this.position);
            if (chase.length() > 0) targetDir = chase.normalize();
          } else {
            if (Math.random() < 0.1) {
              this.currentDirection = randomDirection();
            }
            targetDir = this.currentDirection.normalize();
          }

          if (targetDir && targetDir.length() > 0) {
            this.currentDirection = targetDir;
          }

          const move = this.currentDirection.multiply(this.speed * dt);
          this.position = this.position.add(move);
          this.handleBoundary();

          // 충돌 검사 - 다각형과 다각형 충돌
          const myPolygon = this.getPolygonPoints();
          for (const c of creatures) {
            if (c.type === "Alpha" && c.isAlive) {
              const targetPolygon = c.getPolygonPoints();
              if (polygonsCollide(myPolygon, targetPolygon)) {
                c.isAlive = false;
                this.eatCounter++;
                this.eatAction();
                break;
              }
            }
          }

          if (this.eatCounter >= config.B_Eat_To_Reproduce_Count) {
            this.reproduce(creatures);
          }
        }

        reproduce(creatures) {
          this.eatCounter = 0;
          for (let i = 0; i < config.B_Reproduce_Offspring_Count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * config.Reproduction_Offset_Radius;
            const offset = new Vector2(
              Math.cos(angle),
              Math.sin(angle)
            ).multiply(radius);
            let pos = this.position.add(offset);
            pos.x = Math.max(0, Math.min(config.World_W, pos.x));
            pos.y = Math.max(0, Math.min(config.World_H, pos.y));

            const mutated = this.applyMutation();
            creatures.push(new Beta(pos, mutated.speed, mutated.shapeLengths));
          }
        }
      }

      function initialize() {
        allCreatures = [];
        for (let i = 0; i < config.Init_O_Count; i++) {
          allCreatures.push(new Origin(randomPosition()));
        }
        for (let i = 0; i < config.Init_A_Count; i++) {
          allCreatures.push(new Alpha(randomPosition()));
        }
        for (let i = 0; i < config.Init_B_Count; i++) {
          allCreatures.push(new Beta(randomPosition()));
        }
        simulationTime = 0;
        oSpawnTimer = 0;
      }

      function update(dt) {
        if (paused) return;

        const effectiveDt = dt * speedMultiplier;
        simulationTime += effectiveDt;
        oSpawnTimer += effectiveDt;

        if (oSpawnTimer >= config.O_Spawn_Interval_Seconds) {
          oSpawnTimer = 0;
          for (let i = 0; i < config.O_Spawn_Count_Per_Interval; i++) {
            allCreatures.push(new Origin(randomPosition()));
          }
        }

        for (const c of allCreatures) {
          if (c.isAlive) {
            c.update(effectiveDt, allCreatures);
          }
        }

        allCreatures = allCreatures.filter((c) => c.isAlive);
      }

      function draw() {
        ctx.fillStyle = `rgb(${config.Background_Color[0]}, ${config.Background_Color[1]}, ${config.Background_Color[2]})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (const c of allCreatures) {
          c.draw();
        }
      }

      function updateInfo() {
        const mins = Math.floor(simulationTime / 60);
        const secs = Math.floor(simulationTime % 60);
        document.getElementById("time").textContent = `${String(mins).padStart(
          2,
          "0"
        )}:${String(secs).padStart(2, "0")}`;

        const countO = allCreatures.filter((c) => c.type === "Origin").length;
        const countA = allCreatures.filter((c) => c.type === "Alpha").length;
        const countB = allCreatures.filter((c) => c.type === "Beta").length;

        document.getElementById("countO").textContent = countO;
        document.getElementById("countA").textContent = countA;
        document.getElementById("countB").textContent = countB;

        const alphas = allCreatures.filter((c) => c.type === "Alpha");
        const betas = allCreatures.filter((c) => c.type === "Beta");

        const avgSpeedA =
          alphas.length > 0
            ? alphas.reduce((s, c) => s + c.speed, 0) / alphas.length
            : 0;
        const avgSpeedB =
          betas.length > 0
            ? betas.reduce((s, c) => s + c.speed, 0) / betas.length
            : 0;

        document.getElementById("avgSpeedA").textContent = avgSpeedA.toFixed(1);
        document.getElementById("avgSpeedB").textContent = avgSpeedB.toFixed(1);

        const avgSizeA =
          alphas.length > 0
            ? alphas.reduce(
                (s, c) => s + getAvgShapeLength(c.shapeLengths),
                0
              ) / alphas.length
            : 0;
        const avgSizeB =
          betas.length > 0
            ? betas.reduce((s, c) => s + getAvgShapeLength(c.shapeLengths), 0) /
              betas.length
            : 0;

        document.getElementById("avgSizeA").textContent = avgSizeA.toFixed(1);
        document.getElementById("avgSizeB").textContent = avgSizeB.toFixed(1);

        document.getElementById("speed").textContent =
          speedMultiplier.toFixed(2);
        document.getElementById("paused").textContent = paused ? "(멈춤)" : "";
      }

      function gameLoop(currentTime) {
        const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
        lastTime = currentTime;

        fpsCounter++;
        fpsTime += dt;
        if (fpsTime >= 1.0) {
          document.getElementById("fps").textContent = fpsCounter;
          fpsCounter = 0;
          fpsTime = 0;
        }

        update(dt);
        draw();
        updateInfo();

        requestAnimationFrame(gameLoop);
      }

      function togglePause() {
        paused = !paused;
      }

      function speedUp() {
        speedMultiplier = Math.min(speedMultiplier * 1.5, 32.0);
      }

      function speedDown() {
        speedMultiplier = Math.max(speedMultiplier / 1.5, 0.0625);
      }

      function reset() {
        initialize();
        paused = false;
      }

      // 키보드 컨트롤
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          togglePause();
        } else if (e.code === "Equal" || e.code === "NumpadAdd") {
          speedUp();
        } else if (e.code === "Minus" || e.code === "NumpadSubtract") {
          speedDown();
        } else if (e.code === "KeyR") {
          reset();
        }
      });

      // 시작
      initialize();
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
